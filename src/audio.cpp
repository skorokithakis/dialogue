#include "audio.h"
#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "tusb.h"
#include "class/audio/audio_device.h"   // TinyUSB Audio device API

// TinyUSB currently exposes only CUR & RANGE, but the Linux UAC1 driver
// also sends GET_MIN / GET_MAX / GET_RES.  Define the absent codes here.
#ifndef AUDIO_CS_REQ_MIN
#define AUDIO_CS_REQ_MIN  0x82    // 0b1000'0010  GET_MIN
#endif
#ifndef AUDIO_CS_REQ_MAX
#define AUDIO_CS_REQ_MAX  0x83    //               GET_MAX
#endif
#ifndef AUDIO_CS_REQ_RES
#define AUDIO_CS_REQ_RES  0x84    //               GET_RES
#endif

#define AUDIO_ADC_PIN      26          // GPIO26 = ADC0
#define AUDIO_ADC_CH       0
#define SAMPLE_RATE_HZ     48000
#define SAMPLES_PER_FRAME  48          // 1-ms worth of samples
static int16_t pcm_buf[SAMPLES_PER_FRAME];       // mono

static uint32_t current_sample_rate = SAMPLE_RATE_HZ;            // Hz

/* mono ⇒ channels = 1, add master-channel 0                         */
static uint8_t  cur_mute  [2] = { 0, 0 };      // master + ch-1
static int16_t  cur_volume[2] = { 0, 0 };      // master + ch-1

static const int16_t VOLUME_MIN = int16_t(-60 * 256);   // –60 dB  (1/256 dB units)
static const int16_t VOLUME_MAX = 0;                    //   0 dB
static const int16_t VOLUME_RES = 256;                  //   1 dB step
static const uint8_t MUTE_MIN = 0;
static const uint8_t MUTE_MAX = 1;
static const uint8_t MUTE_RES = 1;
static uint8_t zero_buf[32] = { 0 };   // generic dummy answer

// ------- interface numbers (must match usb_descriptors.c) ------------
#define ITF_NUM_AUDIO_STREAMING_SPK  1   // alt-0 = idle, alt-1 = stream  
#define ITF_NUM_AUDIO_STREAMING_MIC  2   // alt-0 = idle, alt-1 = stream

// ------- function IDs for TinyUSB callbacks -------------------------
#define AUDIO_FUNC_ID_HEADSET        0   // Single headset function

static volatile bool mic_streaming = false;
static volatile bool spk_streaming = false;

/* ------------ TinyUSB callback: stack requests audio data ---------- */
extern "C" bool tud_audio_tx_done_pre_load_cb(uint8_t rhport, uint8_t func_id, uint8_t ep_in, uint8_t cur_alt_setting)
{
  (void)rhport; (void)ep_in; (void)func_id; (void)cur_alt_setting;

  /* Always return false to disable all audio transmission for now */
  return false;
}

/* ------------ TinyUSB callback: speaker samples received ------------- */
extern "C" void tud_audio_rx_done_post_read_cb(uint8_t itf,
                                               uint8_t ep_out,
                                               uint16_t cur_alt_setting,
                                               uint8_t *buffer,
                                               uint16_t buf_size)
{
  if (!spk_streaming) return;        // nothing to do
  (void)itf; (void)ep_out; (void)cur_alt_setting;
  /* TODO: copy ‘buffer’ (buf_size bytes, 16-bit mono @48 kHz) to your DAC.
     For now we just ignore them, keeping the endpoint serviced.         */
}

/* ------------ public helpers ------------------------------------- */
void audio_init(void)
{
  adc_init();
  adc_gpio_init(AUDIO_ADC_PIN);
  adc_select_input(AUDIO_ADC_CH);
  /* continuous-free-running mode – one sample per fifo read       */
  adc_fifo_setup(true, false, 1, false, false);
  adc_run(true);
}

void audio_task(void) { /* nothing needed – callback drives flow */ }

extern "C" {

// entity-IDs generated by TUD_AUDIO_MIC_ONE_CH_DESCRIPTOR()
#define AUDIO_ENTITY_FEATURE_UNIT   0x02
#define AUDIO_ENTITY_CLOCK_SOURCE   0x04

// ── extra entity/control used by the Input-Terminal ────────────────
#define AUDIO_ENTITY_INPUT_TERMINAL  0x01            // produced by
                                                     // TUD_AUDIO_MIC_*_DESCRIPTOR()
#ifndef AUDIO_TE_CTRL_CONNECTOR
#define AUDIO_TE_CTRL_CONNECTOR     0x02            // “Connector” ctl-selector
#endif

/* ------------  SET requests (host → device) ------------------------ */
bool tud_audio_set_req_entity_cb(uint8_t rhport,
                                 tusb_control_request_t const* p_request,
                                 uint8_t*                      p_buff)
{
  uint8_t  entity = TU_U16_HIGH(p_request->wIndex);
  uint8_t  ctrl   = TU_U16_HIGH(p_request->wValue);
  uint8_t  chan   = TU_U16_LOW (p_request->wValue);
  if (chan > 1)                        // only master (0) & ch-1 (1)
    return false;                      // STALL anything above that

  /* Host is changing sample-rate ? ---------------------------------- */
  if( entity == AUDIO_ENTITY_CLOCK_SOURCE &&
      ctrl   == AUDIO_CS_CTRL_SAM_FREQ   &&
      p_request->bRequest == AUDIO_CS_REQ_CUR )
  {
    current_sample_rate =
        (uint32_t)p_buff[0]        |
        ((uint32_t)p_buff[1] << 8) |
        ((uint32_t)p_buff[2] << 16)| 
        ((uint32_t)p_buff[3] << 24);
    return true;
  }

  /* Host is toggling mute ? ----------------------------------------- */
  if( entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_MUTE        &&
      p_request->bRequest == AUDIO_CS_REQ_CUR )
  {
    cur_mute[chan] = p_buff[0];
    return true;
  }

  /* Host sets volume ? ------------------------------------------- */
  if (entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_VOLUME     &&
      p_request->bRequest == AUDIO_CS_REQ_CUR )
  {
    cur_volume[chan] = (int16_t)(p_buff[0] | (p_buff[1] << 8));
    return true;
  }

  /* Host tries to SET the (unused) connector status -------------- */
  if (entity == AUDIO_ENTITY_INPUT_TERMINAL &&
      ctrl   == AUDIO_TE_CTRL_CONNECTOR     &&
      p_request->bRequest == AUDIO_CS_REQ_CUR)
  {
    /* we don’t maintain a runtime connector state → just ACK        */
    return true;
  }

  /* Any other SET_CUR to the Input-Terminal: acknowledge & ignore */
  if (entity == AUDIO_ENTITY_INPUT_TERMINAL &&
      p_request->bRequest == AUDIO_CS_REQ_CUR)
  {
    return true;                        // do nothing, but don’t STALL
  }

  /* Everything else: just acknowledge                                */
  return true;
}

/* ------------  GET requests (device → host) ------------------------ */
bool tud_audio_get_req_entity_cb(uint8_t rhport,
                                 tusb_control_request_t const* p_request)
{
  uint8_t entity = TU_U16_HIGH(p_request->wIndex);
  uint8_t ctrl   = TU_U16_HIGH(p_request->wValue);
  uint8_t chan   = TU_U16_LOW (p_request->wValue);
  if (chan > 1)                        // only master(0) & ch-1(1) valid
    return false;                      // STALL anything above that

  /* ----------- Clock Source (ID 4) answers ------------------------- */
  if( entity == AUDIO_ENTITY_CLOCK_SOURCE )
  {
    if( ctrl == AUDIO_CS_CTRL_SAM_FREQ )
    {
      if( p_request->bRequest == AUDIO_CS_REQ_CUR )
        return tud_control_xfer(rhport, p_request,
                                &current_sample_rate,
                                sizeof(current_sample_rate));

      if( p_request->bRequest == AUDIO_CS_REQ_RANGE )
      {
        struct __attribute__((packed)) {
          uint16_t wNumSubRanges;
          uint32_t tSamFreq[3];           // min / max / res
        } range = { 1, { SAMPLE_RATE_HZ, SAMPLE_RATE_HZ, 0 } };

        return tud_control_xfer(rhport, p_request,
                                &range, sizeof(range));
      }
    }

    if( ctrl == AUDIO_CS_CTRL_CLK_VALID &&
        p_request->bRequest == AUDIO_CS_REQ_CUR )
    {
      static const uint8_t valid = 1;
      return tud_control_xfer(rhport, p_request,
                              (void*)&valid, sizeof(valid));
    }
  }

  /* ----------- Feature Unit (ID 2) answers ------------------------- */
  if (entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_MUTE)
  {
    switch (p_request->bRequest)
    {
      case AUDIO_CS_REQ_CUR:
        return tud_control_xfer(rhport, p_request,
                                &cur_mute[chan], sizeof(uint8_t));

      case AUDIO_CS_REQ_MIN:
        return tud_control_xfer(rhport, p_request,
                                (void*)&MUTE_MIN, sizeof(uint8_t));

      case AUDIO_CS_REQ_MAX:
        return tud_control_xfer(rhport, p_request,
                                (void*)&MUTE_MAX, sizeof(uint8_t));

      case AUDIO_CS_REQ_RES:
        return tud_control_xfer(rhport, p_request,
                                (void*)&MUTE_RES, sizeof(uint8_t));

      case AUDIO_CS_REQ_RANGE: {                     // <-- new
        struct __attribute__((packed)) {
          uint16_t wNumSubRanges;
          uint8_t  bMin, bMax, bRes;
        } mute_range = { 1, MUTE_MIN, MUTE_MAX, MUTE_RES };
        return tud_control_xfer(rhport, p_request,
                                &mute_range, sizeof(mute_range));
      }
    }
  }

  /* ----------- Feature Unit (ID 2) – volume --------------------- */
  if (entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_VOLUME)
  {
    /* current ---------------------------------------------------- */
    if (p_request->bRequest == AUDIO_CS_REQ_CUR)
      return tud_control_xfer(rhport, p_request,
                              &cur_volume[chan], sizeof(int16_t));

    /* min / max / res ------------------------------------------- */
    if (p_request->bRequest == AUDIO_CS_REQ_MIN)
      return tud_control_xfer(rhport, p_request,
                              (void*)&VOLUME_MIN, sizeof(int16_t));

    if (p_request->bRequest == AUDIO_CS_REQ_MAX)
      return tud_control_xfer(rhport, p_request,
                              (void*)&VOLUME_MAX, sizeof(int16_t));

    if (p_request->bRequest == AUDIO_CS_REQ_RES)
      return tud_control_xfer(rhport, p_request,
                              (void*)&VOLUME_RES, sizeof(int16_t));

    /* range ------------------------------------------------------ */
    if (p_request->bRequest == AUDIO_CS_REQ_RANGE)
    {
      struct __attribute__((packed)) {
        uint16_t wNumSubRanges;
        int16_t  wMin, wMax, wRes;
      } vol_range = { 1, VOLUME_MIN, VOLUME_MAX, VOLUME_RES };

      return tud_control_xfer(rhport, p_request,
                              &vol_range, sizeof(vol_range));
    }
  }

  /* ----------- Input Terminal (ID 1) – connector status ---------- */
  if (entity == AUDIO_ENTITY_INPUT_TERMINAL &&
      ctrl   == AUDIO_TE_CTRL_CONNECTOR)
  {
    // Always “embedded / permanently connected” (= 0x0000)
    static const uint16_t conn_cur = 0;

    if (p_request->bRequest == AUDIO_CS_REQ_CUR)
      return tud_control_xfer(rhport, p_request,
                              (void*)&conn_cur, sizeof(conn_cur));

    if (p_request->bRequest == AUDIO_CS_REQ_RANGE)
    {
      struct __attribute__((packed)) {
        uint16_t wNumSubRanges;
        uint16_t wMin, wMax, wRes;
      } conn_range = { 1, 0, 0, 0 };        // fixed at 0
      return tud_control_xfer(rhport, p_request,
                              &conn_range, sizeof(conn_range));
    }

    // MIN / MAX / RES all identical to CUR (0)
    if (   p_request->bRequest == AUDIO_CS_REQ_MIN
        || p_request->bRequest == AUDIO_CS_REQ_MAX
        || p_request->bRequest == AUDIO_CS_REQ_RES)
      return tud_control_xfer(rhport, p_request,
                              (void*)&conn_cur, sizeof(conn_cur));
  }
  
  /* ---------- any other Input-Terminal (ID 1) control ------------ */
  if (entity == AUDIO_ENTITY_INPUT_TERMINAL)        // not CONNECTOR
  {
    // Always “0” (= inactive / not-supported)
    static const uint8_t zero8 = 0;
  
    if (   p_request->bRequest == AUDIO_CS_REQ_CUR
        || p_request->bRequest == AUDIO_CS_REQ_MIN
        || p_request->bRequest == AUDIO_CS_REQ_MAX
        || p_request->bRequest == AUDIO_CS_REQ_RES)
    {
      return tud_control_xfer(rhport, p_request,
                              (void*)&zero8, sizeof(zero8));
    }
  
    if (p_request->bRequest == AUDIO_CS_REQ_RANGE)
    {
      struct __attribute__((packed)) {
        uint16_t wNumSubRanges;
        uint8_t  bMin, bMax, bRes;
      } range8 = { 1, 0, 0, 0 };          // fixed at 0
      return tud_control_xfer(rhport, p_request,
                              &range8, sizeof(range8));
    }
  }
  
  /* ---------- any other request we don’t actively support ---------- */
  uint16_t len = p_request->wLength;                   // host expects …
  if (len > sizeof(zero_buf)) len = sizeof(zero_buf);  // … max 32 bytes
  return tud_control_xfer(rhport, p_request, zero_buf, len);
}

/* ------------  Interface-alternate-setting request --------------- */
bool tud_audio_set_itf_cb(uint8_t rhport,
                          tusb_control_request_t const* p_request)
{
  uint8_t alt_setting = TU_U16_LOW(p_request->wValue);   // 0 = idle
  uint8_t itf         = TU_U16_LOW(p_request->wIndex);   // interface #

  if (itf == ITF_NUM_AUDIO_STREAMING_MIC) {
    mic_streaming = (alt_setting != 0);
    TU_LOG2("  Microphone streaming: %s\r\n", mic_streaming ? "ON" : "OFF");
  }
  else if (itf == ITF_NUM_AUDIO_STREAMING_SPK) {
    spk_streaming = (alt_setting != 0);
    TU_LOG2("  Speaker streaming: %s\r\n", spk_streaming ? "ON" : "OFF");
  }

  return tud_control_status(rhport, p_request);  // ZLP ACK
}

} // extern "C"
