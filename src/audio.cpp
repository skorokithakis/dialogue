#include "audio.h"
#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "tusb.h"
#include "class/audio/audio.h"      // TinyUSB Audio helper macros / types

// TinyUSB currently exposes only CUR & RANGE, but the Linux UAC1 driver
// also sends GET_MIN / GET_MAX / GET_RES.  Define the absent codes here.
#ifndef AUDIO_CS_REQ_MIN
#define AUDIO_CS_REQ_MIN  0x82    // 0b1000'0010  GET_MIN
#endif
#ifndef AUDIO_CS_REQ_MAX
#define AUDIO_CS_REQ_MAX  0x83    //               GET_MAX
#endif
#ifndef AUDIO_CS_REQ_RES
#define AUDIO_CS_REQ_RES  0x84    //               GET_RES
#endif

#define AUDIO_ADC_PIN      26          // GPIO26 = ADC0
#define AUDIO_ADC_CH       0
#define SAMPLE_RATE_HZ     48000
#define SAMPLES_PER_FRAME  48          // 1-ms worth of samples
static int16_t pcm_buf[SAMPLES_PER_FRAME];

static uint32_t current_sample_rate = SAMPLE_RATE_HZ;            // Hz

/* mono ⇒ channels = 1, add master-channel 0                         */
static uint8_t  cur_mute  [2] = { 0, 0 };      // master + ch-1
static int16_t  cur_volume[2] = { 0, 0 };      // master + ch-1

static const int16_t VOLUME_MIN = int16_t(-60 * 256);   // –60 dB  (1/256 dB units)
static const int16_t VOLUME_MAX = 0;                    //   0 dB
static const int16_t VOLUME_RES = 256;                  //   1 dB step
static const uint8_t MUTE_MIN = 0;
static const uint8_t MUTE_MAX = 1;
static const uint8_t MUTE_RES = 1;

/* ------------ TinyUSB callback: stack requests audio data ---------- */
extern "C" uint16_t tud_audio_tx_done_pre_load_cb(uint8_t itf,
                                                  uint8_t ep_in,
                                                  uint16_t cur_alt_setting,
                                                  uint8_t **next_buffer)
{
  (void)itf; (void)ep_in; (void)cur_alt_setting;

  /* Fill pcm_buf with fresh samples ------------------------------ */
  for (uint i = 0; i < SAMPLES_PER_FRAME; ++i)
  {
    uint16_t raw = adc_read();              // 12-bit unsigned
    /* bias-remove + convert to signed 16-bit */
    int16_t  s16 = ((int32_t)raw - 2048) << 4;
    pcm_buf[i] = s16;
  }

  *next_buffer = (uint8_t*)pcm_buf;
  return sizeof(pcm_buf);                   // #bytes made available
}

/* ------------ public helpers ------------------------------------- */
void audio_init(void)
{
  adc_init();
  adc_gpio_init(AUDIO_ADC_PIN);
  adc_select_input(AUDIO_ADC_CH);
  /* continuous-free-running mode – one sample per fifo read       */
  adc_fifo_setup(true, false, 1, false, false);
  adc_run(true);
}

void audio_task(void) { /* nothing needed – callback drives flow */ }

extern "C" {

// entity-IDs generated by TUD_AUDIO_MIC_ONE_CH_DESCRIPTOR()
#define AUDIO_ENTITY_FEATURE_UNIT   0x02
#define AUDIO_ENTITY_CLOCK_SOURCE   0x04

/* ------------  SET requests (host → device) ------------------------ */
bool tud_audio_set_req_entity_cb(uint8_t rhport,
                                 tusb_control_request_t const* p_request,
                                 uint8_t*                      p_buff)
{
  uint8_t  entity = TU_U16_HIGH(p_request->wIndex);
  uint8_t  ctrl   = TU_U16_HIGH(p_request->wValue);
  uint8_t  chan   = TU_U16_LOW (p_request->wValue);
  if (chan > 1)                        // only master(0) & ch-1(1) valid
    return false;                      // STALL anything above that

  /* Host is changing sample-rate ? ---------------------------------- */
  if( entity == AUDIO_ENTITY_CLOCK_SOURCE &&
      ctrl   == AUDIO_CS_CTRL_SAM_FREQ   &&
      p_request->bRequest == AUDIO_CS_REQ_CUR )
  {
    current_sample_rate =
        (uint32_t)p_buff[0]        |
        ((uint32_t)p_buff[1] << 8) |
        ((uint32_t)p_buff[2] << 16)| 
        ((uint32_t)p_buff[3] << 24);
    return true;
  }

  /* Host is toggling mute ? ----------------------------------------- */
  if( entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_MUTE        &&
      p_request->bRequest == AUDIO_CS_REQ_CUR )
  {
    cur_mute[chan] = p_buff[0];
    return true;
  }

  /* Host sets volume ? ------------------------------------------- */
  if (entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_VOLUME     &&
      p_request->bRequest == AUDIO_CS_REQ_CUR )
  {
    cur_volume[chan] = (int16_t)(p_buff[0] | (p_buff[1] << 8));
    return true;
  }

  /* Everything else: just acknowledge                                */
  return true;
}

/* ------------  GET requests (device → host) ------------------------ */
bool tud_audio_get_req_entity_cb(uint8_t rhport,
                                 tusb_control_request_t const* p_request)
{
  uint8_t entity = TU_U16_HIGH(p_request->wIndex);
  uint8_t ctrl   = TU_U16_HIGH(p_request->wValue);
  uint8_t chan   = TU_U16_LOW (p_request->wValue);
  if (chan > 1)                        // only master(0) & ch-1(1) valid
    return false;                      // STALL anything above that

  /* ----------- Clock Source (ID 4) answers ------------------------- */
  if( entity == AUDIO_ENTITY_CLOCK_SOURCE )
  {
    if( ctrl == AUDIO_CS_CTRL_SAM_FREQ )
    {
      if( p_request->bRequest == AUDIO_CS_REQ_CUR )
        return tud_control_xfer(rhport, p_request,
                                &current_sample_rate,
                                sizeof(current_sample_rate));

      if( p_request->bRequest == AUDIO_CS_REQ_RANGE )
      {
        struct __attribute__((packed)) {
          uint16_t wNumSubRanges;
          uint32_t tSamFreq[3];           // min / max / res
        } range = { 1, { SAMPLE_RATE_HZ, SAMPLE_RATE_HZ, 0 } };

        return tud_control_xfer(rhport, p_request,
                                &range, sizeof(range));
      }
    }

    if( ctrl == AUDIO_CS_CTRL_CLK_VALID &&
        p_request->bRequest == AUDIO_CS_REQ_CUR )
    {
      static const uint8_t valid = 1;
      return tud_control_xfer(rhport, p_request,
                              (void*)&valid, sizeof(valid));
    }
  }

  /* ----------- Feature Unit (ID 2) answers ------------------------- */
  if (entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_MUTE)
  {
    switch (p_request->bRequest)
    {
      case AUDIO_CS_REQ_CUR:
        return tud_control_xfer(rhport, p_request,
                                &cur_mute[chan], sizeof(uint8_t));

      case AUDIO_CS_REQ_MIN:
        return tud_control_xfer(rhport, p_request,
                                (void*)&MUTE_MIN, sizeof(uint8_t));

      case AUDIO_CS_REQ_MAX:
        return tud_control_xfer(rhport, p_request,
                                (void*)&MUTE_MAX, sizeof(uint8_t));

      case AUDIO_CS_REQ_RES:
        return tud_control_xfer(rhport, p_request,
                                (void*)&MUTE_RES, sizeof(uint8_t));

      case AUDIO_CS_REQ_RANGE: {                     // <-- new
        struct __attribute__((packed)) {
          uint16_t wNumSubRanges;
          uint8_t  bMin, bMax, bRes;
        } mute_range = { 1, MUTE_MIN, MUTE_MAX, MUTE_RES };
        return tud_control_xfer(rhport, p_request,
                                &mute_range, sizeof(mute_range));
      }
    }
  }

  /* ----------- Feature Unit (ID 2) – volume --------------------- */
  if (entity == AUDIO_ENTITY_FEATURE_UNIT &&
      ctrl   == AUDIO_FU_CTRL_VOLUME)
  {
    /* current ---------------------------------------------------- */
    if (p_request->bRequest == AUDIO_CS_REQ_CUR)
      return tud_control_xfer(rhport, p_request,
                              &cur_volume[chan], sizeof(int16_t));

    /* min / max / res ------------------------------------------- */
    if (p_request->bRequest == AUDIO_CS_REQ_MIN)
      return tud_control_xfer(rhport, p_request,
                              (void*)&VOLUME_MIN, sizeof(int16_t));

    if (p_request->bRequest == AUDIO_CS_REQ_MAX)
      return tud_control_xfer(rhport, p_request,
                              (void*)&VOLUME_MAX, sizeof(int16_t));

    if (p_request->bRequest == AUDIO_CS_REQ_RES)
      return tud_control_xfer(rhport, p_request,
                              (void*)&VOLUME_RES, sizeof(int16_t));

    /* range ------------------------------------------------------ */
    if (p_request->bRequest == AUDIO_CS_REQ_RANGE)
    {
      struct __attribute__((packed)) {
        uint16_t wNumSubRanges;
        int16_t  wMin, wMax, wRes;
      } vol_range = { 1, VOLUME_MIN, VOLUME_MAX, VOLUME_RES };

      return tud_control_xfer(rhport, p_request,
                              &vol_range, sizeof(vol_range));
    }
  }

  /* Unhandled → STALL                                                */
  return false;
}

/* ------------  Interface-alternate-setting request --------------- */
bool tud_audio_set_itf_cb(uint8_t rhport,
                          tusb_control_request_t const* p_request)
{
  uint8_t alt_setting = TU_U16_LOW(p_request->wValue); // 0 = idle, 1 = streaming
  (void)alt_setting;

  /* send the required zero-length status packet */
  return tud_control_status(rhport, p_request);
}

} // extern "C"
